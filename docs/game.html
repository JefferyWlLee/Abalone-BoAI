<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>abalone.game API documentation</title>
<meta name="description" content="This module serves the representation of game states and the performing of game moves." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>abalone.game</code></h1>
</header>
<section id="section-intro">
<p>This module serves the representation of game states and the performing of game moves.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Scriptim/Abalone-BoAi/blob/1623e8ef05411682f95dba45e6566e1275dbc901/abalone/game.py#L0-L317" class="git-link">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

# Copyright 2020 Scriptim (https://github.com/Scriptim)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the &#34;Software&#34;), to deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of
# the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
# THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

&#34;&#34;&#34;This module serves the representation of game states and the performing of game moves.&#34;&#34;&#34;

from copy import deepcopy
from typing import Generator, List, Tuple, Union

import colorama
from colorama import Style

from abalone.enums import Direction, InitialPosition, Marble, Player, Space
from abalone.utils import line_from_to, line_to_edge, neighbor

colorama.init(autoreset=True)


def _space_to_board_indices(space: Space) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;Returns the corresponding index for `self.board` of a given `abalone.enums.Space`.

    Args:
        space: The `abalone.enums.Space` for which the indices are wanted.

    Returns:
        An int tuple containing two indices for `self.board`.
    &#34;&#34;&#34;

    xs = [&#39;I&#39;, &#39;H&#39;, &#39;G&#39;, &#39;F&#39;, &#39;E&#39;, &#39;D&#39;, &#39;C&#39;, &#39;B&#39;, &#39;A&#39;]
    ys = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]

    x = xs.index(space.value[0])
    y = ys.index(space.value[1])

    # offset because lines &#39;F&#39; to &#39;I&#39; don&#39;t start with &#39;1&#39;
    if x &lt;= 3:
        y -= 4 - x

    return x, y


def _marble_of_player(player: Player) -&gt; Marble:
    &#34;&#34;&#34;Returns the corresponding `abalone.enums.Marble` for a given `abalone.enums.Player`.

    Args:
        player: The `abalone.enums.Player` whose `abalone.enums.Marble` is wanted.

    Returns:
        The `abalone.enums.Marble` which belongs to `player`.
    &#34;&#34;&#34;

    return Marble.WHITE if player is Player.WHITE else Marble.BLACK


class Game:
    &#34;&#34;&#34;Represents the mutable state of an Abalone game.&#34;&#34;&#34;

    def __init__(self, initial_position: InitialPosition = InitialPosition.DEFAULT, first_turn: Player = Player.BLACK):
        self.board = deepcopy(initial_position.value)
        self.turn = first_turn

    def __str__(self) -&gt; str:  # pragma: no cover
        board_lines = list(map(lambda line: &#39; &#39;.join(map(str, line)), self.board))
        string = &#39;&#39;
        string += Style.DIM + &#39;    I &#39; + Style.NORMAL + board_lines[0] + &#39;\n&#39;
        string += Style.DIM + &#39;   H &#39; + Style.NORMAL + board_lines[1] + &#39;\n&#39;
        string += Style.DIM + &#39;  G &#39; + Style.NORMAL + board_lines[2] + &#39;\n&#39;
        string += Style.DIM + &#39; F &#39; + Style.NORMAL + board_lines[3] + &#39;\n&#39;
        string += Style.DIM + &#39;E &#39; + Style.NORMAL + board_lines[4] + &#39;\n&#39;
        string += Style.DIM + &#39; D &#39; + Style.NORMAL + board_lines[5] + Style.DIM + &#39; 9\n&#39; + Style.NORMAL
        string += Style.DIM + &#39;  C &#39; + Style.NORMAL + board_lines[6] + Style.DIM + &#39; 8\n&#39; + Style.NORMAL
        string += Style.DIM + &#39;   B &#39; + Style.NORMAL + board_lines[7] + Style.DIM + &#39; 7\n&#39; + Style.NORMAL
        string += Style.DIM + &#39;    A &#39; + Style.NORMAL + board_lines[8] + Style.DIM + &#39; 6\n&#39; + Style.NORMAL
        string += Style.DIM + &#39;       1 2 3 4 5&#39; + Style.NORMAL
        return string

    def not_in_turn_player(self) -&gt; Player:
        &#34;&#34;&#34;Gets the `abalone.enums.Player` who is currently *not* in turn. Returns `abalone.enums.Player.WHITE` when\
        `abalone.enums.Player.BLACK` is in turn and vice versa. This player is commonly referred to as &#34;opponent&#34; in\
        other places.

        Returns:
            The `abalone.enums.Player` not in turn.
        &#34;&#34;&#34;

        return Player.BLACK if self.turn is Player.WHITE else Player.WHITE

    def switch_player(self) -&gt; None:
        &#34;&#34;&#34;Switches the player whose turn it is.&#34;&#34;&#34;
        self.turn = self.not_in_turn_player()

    def set_marble(self, space: Space, marble: Marble) -&gt; None:
        &#34;&#34;&#34;Updates the state of a `abalone.enums.Space` on the board.

        Args:
            space: The `abalone.enums.Space` to be updated.
            marble: The new state of `space` of type `abalone.enums.Marble`

        Raises:
            Exception: Cannot set state of `abalone.enums.Space.OFF`
        &#34;&#34;&#34;

        if space is Space.OFF:
            raise Exception(&#39;Cannot set state of `Space.OFF`&#39;)

        x, y = _space_to_board_indices(space)
        self.board[x][y] = marble

    def get_marble(self, space: Space) -&gt; Marble:
        &#34;&#34;&#34;Returns the state of a `abalone.enums.Space`.

        Args:
            space: The `abalone.enums.Space` of which the state is to be returned.

        Returns:
            A `abalone.enums.Marble` representing the current state of `space`.

        Raises:
            Exception: Cannot get state of `abalone.enums.Space.OFF`
        &#34;&#34;&#34;

        if space is Space.OFF:
            raise Exception(&#39;Cannot get state of `Space.OFF`&#39;)

        x, y = _space_to_board_indices(space)

        return self.board[x][y]

    def get_score(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Counts how many marbles the players still have on the board.

        Returns:
            A tuple with the number of marbles of black and white, in that order.
        &#34;&#34;&#34;
        black = 0
        white = 0
        for row in self.board:
            for space in row:
                if space is Marble.BLACK:
                    black += 1
                elif space is Marble.WHITE:
                    white += 1
        return black, white

    def _inline_marbles_nums(self, line: List[Space]) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Counts the number of own and enemy marbles that are in the given line. First the directly adjacent marbles\
        of the player whose turn it is are counted and then the subsequent directly adjacent marbles of the opponent.\
        Therefore only the marbles that are relevant for an inline move are counted. This method serves as an\
        helper method for `abalone.game.Game.move_inline`.

        Args:
            line: A list of `abalone.enums.Space`s that are in a straight line.

        Returns:
            A tuple with the number of 1. own marbles and 2. opponent marbles, according to the counting method\
            described above.
        &#34;&#34;&#34;
        own_marbles_num = 0
        while own_marbles_num &lt; len(line) and self.get_marble(line[own_marbles_num]) is _marble_of_player(self.turn):
            own_marbles_num += 1
        opp_marbles_num = 0
        while opp_marbles_num + own_marbles_num &lt; len(line) and self.get_marble(
                line[opp_marbles_num + own_marbles_num]) is _marble_of_player(self.not_in_turn_player()):
            opp_marbles_num += 1
        return own_marbles_num, opp_marbles_num

    def move_inline(self, caboose: Space, direction: Direction) -&gt; None:
        &#34;&#34;&#34;Performs an inline move. An inline move is denoted by the trailing marble (&#34;caboose&#34;) of a straight line of\
        marbles. Marbles of the opponent can only be pushed with an inline move (as opposed to a broadside move). This\
        is possible if the opponent&#39;s marbles are directly in front of the line of the player&#39;s own marbles, and only\
        if the opponent&#39;s marbles are outnumbered (&#34;sumito&#34;) and are moved to an empty space or off the board.

        Args:
            caboose: The `abalone.enums.Space` of the trailing marble of a straight line of up to three marbles.
            direction: The `abalone.enums.Direction` of movement.

        Raises:
            IllegalMoveException: Only own marbles may be moved
            IllegalMoveException: Only lines of up to three marbles may be moved
            IllegalMoveException: Own marbles must not be moved off the board
            IllegalMoveException: Only lines that are shorter than the player&#39;s line can be pushed
            IllegalMoveException: Marbles must be pushed to an empty space or off the board
        &#34;&#34;&#34;

        if self.get_marble(caboose) is not _marble_of_player(self.turn):
            raise IllegalMoveException(&#39;Only own marbles may be moved&#39;)

        line = line_to_edge(caboose, direction)
        own_marbles_num, opp_marbles_num = self._inline_marbles_nums(line)

        if own_marbles_num &gt; 3:
            raise IllegalMoveException(&#39;Only lines of up to three marbles may be moved&#39;)

        if own_marbles_num == len(line):
            raise IllegalMoveException(&#39;Own marbles must not be moved off the board&#39;)

        # sumito
        if opp_marbles_num &gt; 0:
            if opp_marbles_num &gt;= own_marbles_num:
                raise IllegalMoveException(&#39;Only lines that are shorter than the player\&#39;s line can be pushed&#39;)
            push_to = neighbor(line[own_marbles_num + opp_marbles_num - 1], direction)
            if push_to is not Space.OFF:
                if self.get_marble(push_to) is _marble_of_player(self.turn):
                    raise IllegalMoveException(&#39;Marbles must be pushed to an empty space or off the board&#39;)
                self.set_marble(push_to, _marble_of_player(self.not_in_turn_player()))

        self.set_marble(line[own_marbles_num], _marble_of_player(self.turn))
        self.set_marble(caboose, Marble.BLANK)

    def move_broadside(self, boundaries: Tuple[Space, Space], direction: Direction) -&gt; None:
        &#34;&#34;&#34;Performs a broadside move. With a broadside move a line of adjacent marbles is moved sideways into empty\
        spaces. However, it is not possible to push the opponent&#39;s marbles. A broadside move is denoted by the two\
        outermost `abalone.enums.Space`s of the line to be moved and the `abalone.enums.Direction` of movement. With a\
        broadside move two or three marbles can be moved, i.e. the two boundary marbles are either direct neighbors or\
        there is exactly one marble in between.

        Args:
            boundaries: A tuple of the two outermost `abalone.enums.Space`s of a line of two or three marbles.
            direction: The `abalone.enums.Direction` of movement.

        Raises:
            IllegalMoveException: Elements of boundaries must not be `abalone.enums.Space.OFF`
            IllegalMoveException: Only two or three neighboring marbles may be moved with a broadside move
            IllegalMoveException: The direction of a broadside move must be sideways
            IllegalMoveException: Only own marbles may be moved
            IllegalMoveException: With a broadside move, marbles can only be moved to empty spaces
        &#34;&#34;&#34;
        if boundaries[0] is Space.OFF or boundaries[1] is Space.OFF:
            raise IllegalMoveException(&#39;Elements of boundaries must not be `Space.OFF`&#39;)
        marbles, direction1 = line_from_to(boundaries[0], boundaries[1])
        if marbles is None or not (len(marbles) == 2 or len(marbles) == 3):
            raise IllegalMoveException(&#39;Only two or three neighboring marbles may be moved with a broadside move&#39;)
        _, direction2 = line_from_to(boundaries[1], boundaries[0])
        if direction is direction1 or direction is direction2:
            raise IllegalMoveException(&#39;The direction of a broadside move must be sideways&#39;)
        for marble in marbles:
            if self.get_marble(marble) is not _marble_of_player(self.turn):
                raise IllegalMoveException(&#39;Only own marbles may be moved&#39;)
            destination_space = neighbor(marble, direction)
            if destination_space is Space.OFF or self.get_marble(destination_space) is not Marble.BLANK:
                raise IllegalMoveException(&#39;With a broadside move, marbles can only be moved to empty spaces&#39;)
        for marble in marbles:
            self.set_marble(marble, Marble.BLANK)
            self.set_marble(neighbor(marble, direction), _marble_of_player(self.turn))

    def move(self, marbles: Union[Space, Tuple[Space, Space]], direction: Direction) -&gt; None:
        &#34;&#34;&#34;Performs either an inline or a broadside move, depending on the arguments passed, by calling the according\
        method (`abalone.game.Game.move_inline` or `abalone.game.Game.move_broadside`).

        Args:
            marbles: The `abalone.enums.Space`s with the marbles to be moved. Either a single space for an inline move\
                or a tuple of two spaces for a broadside move, in accordance with the parameters of\
                `abalone.game.Game.move_inline` resp. `abalone.game.Game.move_broadside`.
            direction: The `abalone.enums.Direction` of movement.

        Raises:
            Exception: Invalid arguments
        &#34;&#34;&#34;
        if isinstance(marbles, Space):
            self.move_inline(marbles, direction)
        elif isinstance(marbles, tuple) and isinstance(marbles[0], Space) and isinstance(marbles[1], Space):
            self.move_broadside(marbles, direction)
        else:  # pragma: no cover
            # This exception should only be raised if the arguments are not passed according to the type hints. It is
            # only there to prevent a silent failure in such a case.
            raise Exception(&#39;Invalid arguments&#39;)

    def generate_own_marble_lines(self) -&gt; Generator[Union[Space, Tuple[Space, Space]], None, None]:
        &#34;&#34;&#34;Generates all adjacent straight lines with up to three marbles of the player whose turn it is.

        Yields:
            Either one or two `abalone.enums.Space`s according to the first parameter of `abalone.game.Game.move`.
        &#34;&#34;&#34;
        for space in Space:
            if space is Space.OFF or self.get_marble(space) is not _marble_of_player(self.turn):
                continue
            yield space
            for direction in [Direction.NORTH_WEST, Direction.NORTH_EAST, Direction.EAST]:
                neighbor1 = neighbor(space, direction)
                if neighbor1 is not Space.OFF and self.get_marble(neighbor1) is _marble_of_player(self.turn):
                    yield space, neighbor1
                    neighbor2 = neighbor(neighbor1, direction)
                    if neighbor2 is not Space.OFF and self.get_marble(neighbor2) is _marble_of_player(self.turn):
                        yield space, neighbor2

    def generate_legal_moves(self) -&gt; Generator[Tuple[Union[Space, Tuple[Space, Space]], Direction], None, None]:
        &#34;&#34;&#34;Generates all possible moves that the player whose turn it is can perform. The yielded values are intended\
        to be passed as arguments to `abalone.game.Game.move`.

        Yields:
            A tuple of 1. either one or a tuple of two `abalone.enums.Space`s and 2. a `abalone.enums.Direction`
        &#34;&#34;&#34;
        for marbles in self.generate_own_marble_lines():
            for direction in Direction:
                copy = deepcopy(self)
                try:
                    copy.move(marbles, direction)
                except IllegalMoveException:
                    continue
                yield marbles, direction


class IllegalMoveException(Exception):
    &#34;&#34;&#34;Exception that is raised if a player tries to perform an illegal move.&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="abalone.game.Game"><code class="flex name class">
<span>class <span class="ident">Game</span></span>
<span>(</span><span>initial_position: <a title="abalone.enums.InitialPosition" href="enums.html#abalone.enums.InitialPosition">InitialPosition</a> = InitialPosition.DEFAULT, first_turn: <a title="abalone.enums.Player" href="enums.html#abalone.enums.Player">Player</a> = Player.BLACK)</span>
</code></dt>
<dd>
<section class="desc"><p>Represents the mutable state of an Abalone game.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Scriptim/Abalone-BoAi/blob/1623e8ef05411682f95dba45e6566e1275dbc901/abalone/game.py#L69-L314" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Game:
    &#34;&#34;&#34;Represents the mutable state of an Abalone game.&#34;&#34;&#34;

    def __init__(self, initial_position: InitialPosition = InitialPosition.DEFAULT, first_turn: Player = Player.BLACK):
        self.board = deepcopy(initial_position.value)
        self.turn = first_turn

    def __str__(self) -&gt; str:  # pragma: no cover
        board_lines = list(map(lambda line: &#39; &#39;.join(map(str, line)), self.board))
        string = &#39;&#39;
        string += Style.DIM + &#39;    I &#39; + Style.NORMAL + board_lines[0] + &#39;\n&#39;
        string += Style.DIM + &#39;   H &#39; + Style.NORMAL + board_lines[1] + &#39;\n&#39;
        string += Style.DIM + &#39;  G &#39; + Style.NORMAL + board_lines[2] + &#39;\n&#39;
        string += Style.DIM + &#39; F &#39; + Style.NORMAL + board_lines[3] + &#39;\n&#39;
        string += Style.DIM + &#39;E &#39; + Style.NORMAL + board_lines[4] + &#39;\n&#39;
        string += Style.DIM + &#39; D &#39; + Style.NORMAL + board_lines[5] + Style.DIM + &#39; 9\n&#39; + Style.NORMAL
        string += Style.DIM + &#39;  C &#39; + Style.NORMAL + board_lines[6] + Style.DIM + &#39; 8\n&#39; + Style.NORMAL
        string += Style.DIM + &#39;   B &#39; + Style.NORMAL + board_lines[7] + Style.DIM + &#39; 7\n&#39; + Style.NORMAL
        string += Style.DIM + &#39;    A &#39; + Style.NORMAL + board_lines[8] + Style.DIM + &#39; 6\n&#39; + Style.NORMAL
        string += Style.DIM + &#39;       1 2 3 4 5&#39; + Style.NORMAL
        return string

    def not_in_turn_player(self) -&gt; Player:
        &#34;&#34;&#34;Gets the `abalone.enums.Player` who is currently *not* in turn. Returns `abalone.enums.Player.WHITE` when\
        `abalone.enums.Player.BLACK` is in turn and vice versa. This player is commonly referred to as &#34;opponent&#34; in\
        other places.

        Returns:
            The `abalone.enums.Player` not in turn.
        &#34;&#34;&#34;

        return Player.BLACK if self.turn is Player.WHITE else Player.WHITE

    def switch_player(self) -&gt; None:
        &#34;&#34;&#34;Switches the player whose turn it is.&#34;&#34;&#34;
        self.turn = self.not_in_turn_player()

    def set_marble(self, space: Space, marble: Marble) -&gt; None:
        &#34;&#34;&#34;Updates the state of a `abalone.enums.Space` on the board.

        Args:
            space: The `abalone.enums.Space` to be updated.
            marble: The new state of `space` of type `abalone.enums.Marble`

        Raises:
            Exception: Cannot set state of `abalone.enums.Space.OFF`
        &#34;&#34;&#34;

        if space is Space.OFF:
            raise Exception(&#39;Cannot set state of `Space.OFF`&#39;)

        x, y = _space_to_board_indices(space)
        self.board[x][y] = marble

    def get_marble(self, space: Space) -&gt; Marble:
        &#34;&#34;&#34;Returns the state of a `abalone.enums.Space`.

        Args:
            space: The `abalone.enums.Space` of which the state is to be returned.

        Returns:
            A `abalone.enums.Marble` representing the current state of `space`.

        Raises:
            Exception: Cannot get state of `abalone.enums.Space.OFF`
        &#34;&#34;&#34;

        if space is Space.OFF:
            raise Exception(&#39;Cannot get state of `Space.OFF`&#39;)

        x, y = _space_to_board_indices(space)

        return self.board[x][y]

    def get_score(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Counts how many marbles the players still have on the board.

        Returns:
            A tuple with the number of marbles of black and white, in that order.
        &#34;&#34;&#34;
        black = 0
        white = 0
        for row in self.board:
            for space in row:
                if space is Marble.BLACK:
                    black += 1
                elif space is Marble.WHITE:
                    white += 1
        return black, white

    def _inline_marbles_nums(self, line: List[Space]) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Counts the number of own and enemy marbles that are in the given line. First the directly adjacent marbles\
        of the player whose turn it is are counted and then the subsequent directly adjacent marbles of the opponent.\
        Therefore only the marbles that are relevant for an inline move are counted. This method serves as an\
        helper method for `abalone.game.Game.move_inline`.

        Args:
            line: A list of `abalone.enums.Space`s that are in a straight line.

        Returns:
            A tuple with the number of 1. own marbles and 2. opponent marbles, according to the counting method\
            described above.
        &#34;&#34;&#34;
        own_marbles_num = 0
        while own_marbles_num &lt; len(line) and self.get_marble(line[own_marbles_num]) is _marble_of_player(self.turn):
            own_marbles_num += 1
        opp_marbles_num = 0
        while opp_marbles_num + own_marbles_num &lt; len(line) and self.get_marble(
                line[opp_marbles_num + own_marbles_num]) is _marble_of_player(self.not_in_turn_player()):
            opp_marbles_num += 1
        return own_marbles_num, opp_marbles_num

    def move_inline(self, caboose: Space, direction: Direction) -&gt; None:
        &#34;&#34;&#34;Performs an inline move. An inline move is denoted by the trailing marble (&#34;caboose&#34;) of a straight line of\
        marbles. Marbles of the opponent can only be pushed with an inline move (as opposed to a broadside move). This\
        is possible if the opponent&#39;s marbles are directly in front of the line of the player&#39;s own marbles, and only\
        if the opponent&#39;s marbles are outnumbered (&#34;sumito&#34;) and are moved to an empty space or off the board.

        Args:
            caboose: The `abalone.enums.Space` of the trailing marble of a straight line of up to three marbles.
            direction: The `abalone.enums.Direction` of movement.

        Raises:
            IllegalMoveException: Only own marbles may be moved
            IllegalMoveException: Only lines of up to three marbles may be moved
            IllegalMoveException: Own marbles must not be moved off the board
            IllegalMoveException: Only lines that are shorter than the player&#39;s line can be pushed
            IllegalMoveException: Marbles must be pushed to an empty space or off the board
        &#34;&#34;&#34;

        if self.get_marble(caboose) is not _marble_of_player(self.turn):
            raise IllegalMoveException(&#39;Only own marbles may be moved&#39;)

        line = line_to_edge(caboose, direction)
        own_marbles_num, opp_marbles_num = self._inline_marbles_nums(line)

        if own_marbles_num &gt; 3:
            raise IllegalMoveException(&#39;Only lines of up to three marbles may be moved&#39;)

        if own_marbles_num == len(line):
            raise IllegalMoveException(&#39;Own marbles must not be moved off the board&#39;)

        # sumito
        if opp_marbles_num &gt; 0:
            if opp_marbles_num &gt;= own_marbles_num:
                raise IllegalMoveException(&#39;Only lines that are shorter than the player\&#39;s line can be pushed&#39;)
            push_to = neighbor(line[own_marbles_num + opp_marbles_num - 1], direction)
            if push_to is not Space.OFF:
                if self.get_marble(push_to) is _marble_of_player(self.turn):
                    raise IllegalMoveException(&#39;Marbles must be pushed to an empty space or off the board&#39;)
                self.set_marble(push_to, _marble_of_player(self.not_in_turn_player()))

        self.set_marble(line[own_marbles_num], _marble_of_player(self.turn))
        self.set_marble(caboose, Marble.BLANK)

    def move_broadside(self, boundaries: Tuple[Space, Space], direction: Direction) -&gt; None:
        &#34;&#34;&#34;Performs a broadside move. With a broadside move a line of adjacent marbles is moved sideways into empty\
        spaces. However, it is not possible to push the opponent&#39;s marbles. A broadside move is denoted by the two\
        outermost `abalone.enums.Space`s of the line to be moved and the `abalone.enums.Direction` of movement. With a\
        broadside move two or three marbles can be moved, i.e. the two boundary marbles are either direct neighbors or\
        there is exactly one marble in between.

        Args:
            boundaries: A tuple of the two outermost `abalone.enums.Space`s of a line of two or three marbles.
            direction: The `abalone.enums.Direction` of movement.

        Raises:
            IllegalMoveException: Elements of boundaries must not be `abalone.enums.Space.OFF`
            IllegalMoveException: Only two or three neighboring marbles may be moved with a broadside move
            IllegalMoveException: The direction of a broadside move must be sideways
            IllegalMoveException: Only own marbles may be moved
            IllegalMoveException: With a broadside move, marbles can only be moved to empty spaces
        &#34;&#34;&#34;
        if boundaries[0] is Space.OFF or boundaries[1] is Space.OFF:
            raise IllegalMoveException(&#39;Elements of boundaries must not be `Space.OFF`&#39;)
        marbles, direction1 = line_from_to(boundaries[0], boundaries[1])
        if marbles is None or not (len(marbles) == 2 or len(marbles) == 3):
            raise IllegalMoveException(&#39;Only two or three neighboring marbles may be moved with a broadside move&#39;)
        _, direction2 = line_from_to(boundaries[1], boundaries[0])
        if direction is direction1 or direction is direction2:
            raise IllegalMoveException(&#39;The direction of a broadside move must be sideways&#39;)
        for marble in marbles:
            if self.get_marble(marble) is not _marble_of_player(self.turn):
                raise IllegalMoveException(&#39;Only own marbles may be moved&#39;)
            destination_space = neighbor(marble, direction)
            if destination_space is Space.OFF or self.get_marble(destination_space) is not Marble.BLANK:
                raise IllegalMoveException(&#39;With a broadside move, marbles can only be moved to empty spaces&#39;)
        for marble in marbles:
            self.set_marble(marble, Marble.BLANK)
            self.set_marble(neighbor(marble, direction), _marble_of_player(self.turn))

    def move(self, marbles: Union[Space, Tuple[Space, Space]], direction: Direction) -&gt; None:
        &#34;&#34;&#34;Performs either an inline or a broadside move, depending on the arguments passed, by calling the according\
        method (`abalone.game.Game.move_inline` or `abalone.game.Game.move_broadside`).

        Args:
            marbles: The `abalone.enums.Space`s with the marbles to be moved. Either a single space for an inline move\
                or a tuple of two spaces for a broadside move, in accordance with the parameters of\
                `abalone.game.Game.move_inline` resp. `abalone.game.Game.move_broadside`.
            direction: The `abalone.enums.Direction` of movement.

        Raises:
            Exception: Invalid arguments
        &#34;&#34;&#34;
        if isinstance(marbles, Space):
            self.move_inline(marbles, direction)
        elif isinstance(marbles, tuple) and isinstance(marbles[0], Space) and isinstance(marbles[1], Space):
            self.move_broadside(marbles, direction)
        else:  # pragma: no cover
            # This exception should only be raised if the arguments are not passed according to the type hints. It is
            # only there to prevent a silent failure in such a case.
            raise Exception(&#39;Invalid arguments&#39;)

    def generate_own_marble_lines(self) -&gt; Generator[Union[Space, Tuple[Space, Space]], None, None]:
        &#34;&#34;&#34;Generates all adjacent straight lines with up to three marbles of the player whose turn it is.

        Yields:
            Either one or two `abalone.enums.Space`s according to the first parameter of `abalone.game.Game.move`.
        &#34;&#34;&#34;
        for space in Space:
            if space is Space.OFF or self.get_marble(space) is not _marble_of_player(self.turn):
                continue
            yield space
            for direction in [Direction.NORTH_WEST, Direction.NORTH_EAST, Direction.EAST]:
                neighbor1 = neighbor(space, direction)
                if neighbor1 is not Space.OFF and self.get_marble(neighbor1) is _marble_of_player(self.turn):
                    yield space, neighbor1
                    neighbor2 = neighbor(neighbor1, direction)
                    if neighbor2 is not Space.OFF and self.get_marble(neighbor2) is _marble_of_player(self.turn):
                        yield space, neighbor2

    def generate_legal_moves(self) -&gt; Generator[Tuple[Union[Space, Tuple[Space, Space]], Direction], None, None]:
        &#34;&#34;&#34;Generates all possible moves that the player whose turn it is can perform. The yielded values are intended\
        to be passed as arguments to `abalone.game.Game.move`.

        Yields:
            A tuple of 1. either one or a tuple of two `abalone.enums.Space`s and 2. a `abalone.enums.Direction`
        &#34;&#34;&#34;
        for marbles in self.generate_own_marble_lines():
            for direction in Direction:
                copy = deepcopy(self)
                try:
                    copy.move(marbles, direction)
                except IllegalMoveException:
                    continue
                yield marbles, direction</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="abalone.game.Game.generate_legal_moves"><code class="name flex">
<span>def <span class="ident">generate_legal_moves</span></span>(<span>self) -> Generator[Tuple[Union[<a title="abalone.enums.Space" href="enums.html#abalone.enums.Space">Space</a>, Tuple[<a title="abalone.enums.Space" href="enums.html#abalone.enums.Space">Space</a>, <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space">Space</a>]], <a title="abalone.enums.Direction" href="enums.html#abalone.enums.Direction">Direction</a>], NoneType, NoneType]</span>
</code></dt>
<dd>
<section class="desc"><p>Generates all possible moves that the player whose turn it is can perform. The yielded values are intended
to be passed as arguments to <a title="abalone.game.Game.move" href="#abalone.game.Game.move"><code>Game.move()</code></a>.</p>
<h2 id="yields">Yields</h2>
<p>A tuple of 1. either one or a tuple of two <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space"><code>Space</code></a>s and 2. a <a title="abalone.enums.Direction" href="enums.html#abalone.enums.Direction"><code>Direction</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Scriptim/Abalone-BoAi/blob/1623e8ef05411682f95dba45e6566e1275dbc901/abalone/game.py#L300-L314" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def generate_legal_moves(self) -&gt; Generator[Tuple[Union[Space, Tuple[Space, Space]], Direction], None, None]:
    &#34;&#34;&#34;Generates all possible moves that the player whose turn it is can perform. The yielded values are intended\
    to be passed as arguments to `abalone.game.Game.move`.

    Yields:
        A tuple of 1. either one or a tuple of two `abalone.enums.Space`s and 2. a `abalone.enums.Direction`
    &#34;&#34;&#34;
    for marbles in self.generate_own_marble_lines():
        for direction in Direction:
            copy = deepcopy(self)
            try:
                copy.move(marbles, direction)
            except IllegalMoveException:
                continue
            yield marbles, direction</code></pre>
</details>
</dd>
<dt id="abalone.game.Game.generate_own_marble_lines"><code class="name flex">
<span>def <span class="ident">generate_own_marble_lines</span></span>(<span>self) -> Generator[Union[<a title="abalone.enums.Space" href="enums.html#abalone.enums.Space">Space</a>, Tuple[<a title="abalone.enums.Space" href="enums.html#abalone.enums.Space">Space</a>, <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space">Space</a>]], NoneType, NoneType]</span>
</code></dt>
<dd>
<section class="desc"><p>Generates all adjacent straight lines with up to three marbles of the player whose turn it is.</p>
<h2 id="yields">Yields</h2>
<p>Either one or two <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space"><code>Space</code></a>s according to the first parameter of <a title="abalone.game.Game.move" href="#abalone.game.Game.move"><code>Game.move()</code></a>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Scriptim/Abalone-BoAi/blob/1623e8ef05411682f95dba45e6566e1275dbc901/abalone/game.py#L282-L298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def generate_own_marble_lines(self) -&gt; Generator[Union[Space, Tuple[Space, Space]], None, None]:
    &#34;&#34;&#34;Generates all adjacent straight lines with up to three marbles of the player whose turn it is.

    Yields:
        Either one or two `abalone.enums.Space`s according to the first parameter of `abalone.game.Game.move`.
    &#34;&#34;&#34;
    for space in Space:
        if space is Space.OFF or self.get_marble(space) is not _marble_of_player(self.turn):
            continue
        yield space
        for direction in [Direction.NORTH_WEST, Direction.NORTH_EAST, Direction.EAST]:
            neighbor1 = neighbor(space, direction)
            if neighbor1 is not Space.OFF and self.get_marble(neighbor1) is _marble_of_player(self.turn):
                yield space, neighbor1
                neighbor2 = neighbor(neighbor1, direction)
                if neighbor2 is not Space.OFF and self.get_marble(neighbor2) is _marble_of_player(self.turn):
                    yield space, neighbor2</code></pre>
</details>
</dd>
<dt id="abalone.game.Game.get_marble"><code class="name flex">
<span>def <span class="ident">get_marble</span></span>(<span>self, space: <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space">Space</a>) -> <a title="abalone.enums.Marble" href="enums.html#abalone.enums.Marble">Marble</a></span>
</code></dt>
<dd>
<section class="desc"><p>Returns the state of a <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space"><code>Space</code></a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>space</code></strong></dt>
<dd>The <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space"><code>Space</code></a> of which the state is to be returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A <a title="abalone.enums.Marble" href="enums.html#abalone.enums.Marble"><code>Marble</code></a> representing the current state of <code>space</code>.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong></dt>
<dd>Cannot get state of <a title="abalone.enums.Space.OFF" href="enums.html#abalone.enums.Space.OFF"><code>Space.OFF</code></a></dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Scriptim/Abalone-BoAi/blob/1623e8ef05411682f95dba45e6566e1275dbc901/abalone/game.py#L123-L141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_marble(self, space: Space) -&gt; Marble:
    &#34;&#34;&#34;Returns the state of a `abalone.enums.Space`.

    Args:
        space: The `abalone.enums.Space` of which the state is to be returned.

    Returns:
        A `abalone.enums.Marble` representing the current state of `space`.

    Raises:
        Exception: Cannot get state of `abalone.enums.Space.OFF`
    &#34;&#34;&#34;

    if space is Space.OFF:
        raise Exception(&#39;Cannot get state of `Space.OFF`&#39;)

    x, y = _space_to_board_indices(space)

    return self.board[x][y]</code></pre>
</details>
</dd>
<dt id="abalone.game.Game.get_score"><code class="name flex">
<span>def <span class="ident">get_score</span></span>(<span>self) -> Tuple[int, int]</span>
</code></dt>
<dd>
<section class="desc"><p>Counts how many marbles the players still have on the board.</p>
<h2 id="returns">Returns</h2>
<p>A tuple with the number of marbles of black and white, in that order.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Scriptim/Abalone-BoAi/blob/1623e8ef05411682f95dba45e6566e1275dbc901/abalone/game.py#L143-L157" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_score(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;Counts how many marbles the players still have on the board.

    Returns:
        A tuple with the number of marbles of black and white, in that order.
    &#34;&#34;&#34;
    black = 0
    white = 0
    for row in self.board:
        for space in row:
            if space is Marble.BLACK:
                black += 1
            elif space is Marble.WHITE:
                white += 1
    return black, white</code></pre>
</details>
</dd>
<dt id="abalone.game.Game.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, marbles: Union[abalone.enums.Space, Tuple[abalone.enums.Space, abalone.enums.Space]], direction: <a title="abalone.enums.Direction" href="enums.html#abalone.enums.Direction">Direction</a>) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Performs either an inline or a broadside move, depending on the arguments passed, by calling the according
method (<a title="abalone.game.Game.move_inline" href="#abalone.game.Game.move_inline"><code>Game.move_inline()</code></a> or <a title="abalone.game.Game.move_broadside" href="#abalone.game.Game.move_broadside"><code>Game.move_broadside()</code></a>).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>marbles</code></strong></dt>
<dd>The <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space"><code>Space</code></a>s with the marbles to be moved. Either a single space for an inline move
or a tuple of two spaces for a broadside move, in accordance with the parameters of
<a title="abalone.game.Game.move_inline" href="#abalone.game.Game.move_inline"><code>Game.move_inline()</code></a> resp. <a title="abalone.game.Game.move_broadside" href="#abalone.game.Game.move_broadside"><code>Game.move_broadside()</code></a>.</dd>
<dt><strong><code>direction</code></strong></dt>
<dd>The <a title="abalone.enums.Direction" href="enums.html#abalone.enums.Direction"><code>Direction</code></a> of movement.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong></dt>
<dd>Invalid arguments</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Scriptim/Abalone-BoAi/blob/1623e8ef05411682f95dba45e6566e1275dbc901/abalone/game.py#L260-L280" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def move(self, marbles: Union[Space, Tuple[Space, Space]], direction: Direction) -&gt; None:
    &#34;&#34;&#34;Performs either an inline or a broadside move, depending on the arguments passed, by calling the according\
    method (`abalone.game.Game.move_inline` or `abalone.game.Game.move_broadside`).

    Args:
        marbles: The `abalone.enums.Space`s with the marbles to be moved. Either a single space for an inline move\
            or a tuple of two spaces for a broadside move, in accordance with the parameters of\
            `abalone.game.Game.move_inline` resp. `abalone.game.Game.move_broadside`.
        direction: The `abalone.enums.Direction` of movement.

    Raises:
        Exception: Invalid arguments
    &#34;&#34;&#34;
    if isinstance(marbles, Space):
        self.move_inline(marbles, direction)
    elif isinstance(marbles, tuple) and isinstance(marbles[0], Space) and isinstance(marbles[1], Space):
        self.move_broadside(marbles, direction)
    else:  # pragma: no cover
        # This exception should only be raised if the arguments are not passed according to the type hints. It is
        # only there to prevent a silent failure in such a case.
        raise Exception(&#39;Invalid arguments&#39;)</code></pre>
</details>
</dd>
<dt id="abalone.game.Game.move_broadside"><code class="name flex">
<span>def <span class="ident">move_broadside</span></span>(<span>self, boundaries: Tuple[abalone.enums.Space, abalone.enums.Space], direction: <a title="abalone.enums.Direction" href="enums.html#abalone.enums.Direction">Direction</a>) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Performs a broadside move. With a broadside move a line of adjacent marbles is moved sideways into empty
spaces. However, it is not possible to push the opponent's marbles. A broadside move is denoted by the two
outermost <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space"><code>Space</code></a>s of the line to be moved and the <a title="abalone.enums.Direction" href="enums.html#abalone.enums.Direction"><code>Direction</code></a> of movement. With a
broadside move two or three marbles can be moved, i.e. the two boundary marbles are either direct neighbors or
there is exactly one marble in between.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>boundaries</code></strong></dt>
<dd>A tuple of the two outermost <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space"><code>Space</code></a>s of a line of two or three marbles.</dd>
<dt><strong><code>direction</code></strong></dt>
<dd>The <a title="abalone.enums.Direction" href="enums.html#abalone.enums.Direction"><code>Direction</code></a> of movement.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><a title="abalone.game.IllegalMoveException" href="#abalone.game.IllegalMoveException"><code>IllegalMoveException</code></a></strong></dt>
<dd>Elements of boundaries must not be <a title="abalone.enums.Space.OFF" href="enums.html#abalone.enums.Space.OFF"><code>Space.OFF</code></a></dd>
<dt><strong><a title="abalone.game.IllegalMoveException" href="#abalone.game.IllegalMoveException"><code>IllegalMoveException</code></a></strong></dt>
<dd>Only two or three neighboring marbles may be moved with a broadside move</dd>
<dt><strong><a title="abalone.game.IllegalMoveException" href="#abalone.game.IllegalMoveException"><code>IllegalMoveException</code></a></strong></dt>
<dd>The direction of a broadside move must be sideways</dd>
<dt><strong><a title="abalone.game.IllegalMoveException" href="#abalone.game.IllegalMoveException"><code>IllegalMoveException</code></a></strong></dt>
<dd>Only own marbles may be moved</dd>
<dt><strong><a title="abalone.game.IllegalMoveException" href="#abalone.game.IllegalMoveException"><code>IllegalMoveException</code></a></strong></dt>
<dd>With a broadside move, marbles can only be moved to empty spaces</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Scriptim/Abalone-BoAi/blob/1623e8ef05411682f95dba45e6566e1275dbc901/abalone/game.py#L224-L258" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def move_broadside(self, boundaries: Tuple[Space, Space], direction: Direction) -&gt; None:
    &#34;&#34;&#34;Performs a broadside move. With a broadside move a line of adjacent marbles is moved sideways into empty\
    spaces. However, it is not possible to push the opponent&#39;s marbles. A broadside move is denoted by the two\
    outermost `abalone.enums.Space`s of the line to be moved and the `abalone.enums.Direction` of movement. With a\
    broadside move two or three marbles can be moved, i.e. the two boundary marbles are either direct neighbors or\
    there is exactly one marble in between.

    Args:
        boundaries: A tuple of the two outermost `abalone.enums.Space`s of a line of two or three marbles.
        direction: The `abalone.enums.Direction` of movement.

    Raises:
        IllegalMoveException: Elements of boundaries must not be `abalone.enums.Space.OFF`
        IllegalMoveException: Only two or three neighboring marbles may be moved with a broadside move
        IllegalMoveException: The direction of a broadside move must be sideways
        IllegalMoveException: Only own marbles may be moved
        IllegalMoveException: With a broadside move, marbles can only be moved to empty spaces
    &#34;&#34;&#34;
    if boundaries[0] is Space.OFF or boundaries[1] is Space.OFF:
        raise IllegalMoveException(&#39;Elements of boundaries must not be `Space.OFF`&#39;)
    marbles, direction1 = line_from_to(boundaries[0], boundaries[1])
    if marbles is None or not (len(marbles) == 2 or len(marbles) == 3):
        raise IllegalMoveException(&#39;Only two or three neighboring marbles may be moved with a broadside move&#39;)
    _, direction2 = line_from_to(boundaries[1], boundaries[0])
    if direction is direction1 or direction is direction2:
        raise IllegalMoveException(&#39;The direction of a broadside move must be sideways&#39;)
    for marble in marbles:
        if self.get_marble(marble) is not _marble_of_player(self.turn):
            raise IllegalMoveException(&#39;Only own marbles may be moved&#39;)
        destination_space = neighbor(marble, direction)
        if destination_space is Space.OFF or self.get_marble(destination_space) is not Marble.BLANK:
            raise IllegalMoveException(&#39;With a broadside move, marbles can only be moved to empty spaces&#39;)
    for marble in marbles:
        self.set_marble(marble, Marble.BLANK)
        self.set_marble(neighbor(marble, direction), _marble_of_player(self.turn))</code></pre>
</details>
</dd>
<dt id="abalone.game.Game.move_inline"><code class="name flex">
<span>def <span class="ident">move_inline</span></span>(<span>self, caboose: <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space">Space</a>, direction: <a title="abalone.enums.Direction" href="enums.html#abalone.enums.Direction">Direction</a>) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Performs an inline move. An inline move is denoted by the trailing marble ("caboose") of a straight line of
marbles. Marbles of the opponent can only be pushed with an inline move (as opposed to a broadside move). This
is possible if the opponent's marbles are directly in front of the line of the player's own marbles, and only
if the opponent's marbles are outnumbered ("sumito") and are moved to an empty space or off the board.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>caboose</code></strong></dt>
<dd>The <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space"><code>Space</code></a> of the trailing marble of a straight line of up to three marbles.</dd>
<dt><strong><code>direction</code></strong></dt>
<dd>The <a title="abalone.enums.Direction" href="enums.html#abalone.enums.Direction"><code>Direction</code></a> of movement.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><a title="abalone.game.IllegalMoveException" href="#abalone.game.IllegalMoveException"><code>IllegalMoveException</code></a></strong></dt>
<dd>Only own marbles may be moved</dd>
<dt><strong><a title="abalone.game.IllegalMoveException" href="#abalone.game.IllegalMoveException"><code>IllegalMoveException</code></a></strong></dt>
<dd>Only lines of up to three marbles may be moved</dd>
<dt><strong><a title="abalone.game.IllegalMoveException" href="#abalone.game.IllegalMoveException"><code>IllegalMoveException</code></a></strong></dt>
<dd>Own marbles must not be moved off the board</dd>
<dt><strong><a title="abalone.game.IllegalMoveException" href="#abalone.game.IllegalMoveException"><code>IllegalMoveException</code></a></strong></dt>
<dd>Only lines that are shorter than the player's line can be pushed</dd>
<dt><strong><a title="abalone.game.IllegalMoveException" href="#abalone.game.IllegalMoveException"><code>IllegalMoveException</code></a></strong></dt>
<dd>Marbles must be pushed to an empty space or off the board</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Scriptim/Abalone-BoAi/blob/1623e8ef05411682f95dba45e6566e1275dbc901/abalone/game.py#L181-L222" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def move_inline(self, caboose: Space, direction: Direction) -&gt; None:
    &#34;&#34;&#34;Performs an inline move. An inline move is denoted by the trailing marble (&#34;caboose&#34;) of a straight line of\
    marbles. Marbles of the opponent can only be pushed with an inline move (as opposed to a broadside move). This\
    is possible if the opponent&#39;s marbles are directly in front of the line of the player&#39;s own marbles, and only\
    if the opponent&#39;s marbles are outnumbered (&#34;sumito&#34;) and are moved to an empty space or off the board.

    Args:
        caboose: The `abalone.enums.Space` of the trailing marble of a straight line of up to three marbles.
        direction: The `abalone.enums.Direction` of movement.

    Raises:
        IllegalMoveException: Only own marbles may be moved
        IllegalMoveException: Only lines of up to three marbles may be moved
        IllegalMoveException: Own marbles must not be moved off the board
        IllegalMoveException: Only lines that are shorter than the player&#39;s line can be pushed
        IllegalMoveException: Marbles must be pushed to an empty space or off the board
    &#34;&#34;&#34;

    if self.get_marble(caboose) is not _marble_of_player(self.turn):
        raise IllegalMoveException(&#39;Only own marbles may be moved&#39;)

    line = line_to_edge(caboose, direction)
    own_marbles_num, opp_marbles_num = self._inline_marbles_nums(line)

    if own_marbles_num &gt; 3:
        raise IllegalMoveException(&#39;Only lines of up to three marbles may be moved&#39;)

    if own_marbles_num == len(line):
        raise IllegalMoveException(&#39;Own marbles must not be moved off the board&#39;)

    # sumito
    if opp_marbles_num &gt; 0:
        if opp_marbles_num &gt;= own_marbles_num:
            raise IllegalMoveException(&#39;Only lines that are shorter than the player\&#39;s line can be pushed&#39;)
        push_to = neighbor(line[own_marbles_num + opp_marbles_num - 1], direction)
        if push_to is not Space.OFF:
            if self.get_marble(push_to) is _marble_of_player(self.turn):
                raise IllegalMoveException(&#39;Marbles must be pushed to an empty space or off the board&#39;)
            self.set_marble(push_to, _marble_of_player(self.not_in_turn_player()))

    self.set_marble(line[own_marbles_num], _marble_of_player(self.turn))
    self.set_marble(caboose, Marble.BLANK)</code></pre>
</details>
</dd>
<dt id="abalone.game.Game.not_in_turn_player"><code class="name flex">
<span>def <span class="ident">not_in_turn_player</span></span>(<span>self) -> <a title="abalone.enums.Player" href="enums.html#abalone.enums.Player">Player</a></span>
</code></dt>
<dd>
<section class="desc"><p>Gets the <a title="abalone.enums.Player" href="enums.html#abalone.enums.Player"><code>Player</code></a> who is currently <em>not</em> in turn. Returns <a title="abalone.enums.Player.WHITE" href="enums.html#abalone.enums.Player.WHITE"><code>Player.WHITE</code></a> when
<a title="abalone.enums.Player.BLACK" href="enums.html#abalone.enums.Player.BLACK"><code>Player.BLACK</code></a> is in turn and vice versa. This player is commonly referred to as "opponent" in
other places.</p>
<h2 id="returns">Returns</h2>
<p>The <a title="abalone.enums.Player" href="enums.html#abalone.enums.Player"><code>Player</code></a> not in turn.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Scriptim/Abalone-BoAi/blob/1623e8ef05411682f95dba45e6566e1275dbc901/abalone/game.py#L91-L100" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def not_in_turn_player(self) -&gt; Player:
    &#34;&#34;&#34;Gets the `abalone.enums.Player` who is currently *not* in turn. Returns `abalone.enums.Player.WHITE` when\
    `abalone.enums.Player.BLACK` is in turn and vice versa. This player is commonly referred to as &#34;opponent&#34; in\
    other places.

    Returns:
        The `abalone.enums.Player` not in turn.
    &#34;&#34;&#34;

    return Player.BLACK if self.turn is Player.WHITE else Player.WHITE</code></pre>
</details>
</dd>
<dt id="abalone.game.Game.set_marble"><code class="name flex">
<span>def <span class="ident">set_marble</span></span>(<span>self, space: <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space">Space</a>, marble: <a title="abalone.enums.Marble" href="enums.html#abalone.enums.Marble">Marble</a>) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Updates the state of a <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space"><code>Space</code></a> on the board.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>space</code></strong></dt>
<dd>The <a title="abalone.enums.Space" href="enums.html#abalone.enums.Space"><code>Space</code></a> to be updated.</dd>
<dt><strong><code>marble</code></strong></dt>
<dd>The new state of <code>space</code> of type <a title="abalone.enums.Marble" href="enums.html#abalone.enums.Marble"><code>Marble</code></a></dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong></dt>
<dd>Cannot set state of <a title="abalone.enums.Space.OFF" href="enums.html#abalone.enums.Space.OFF"><code>Space.OFF</code></a></dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Scriptim/Abalone-BoAi/blob/1623e8ef05411682f95dba45e6566e1275dbc901/abalone/game.py#L106-L121" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_marble(self, space: Space, marble: Marble) -&gt; None:
    &#34;&#34;&#34;Updates the state of a `abalone.enums.Space` on the board.

    Args:
        space: The `abalone.enums.Space` to be updated.
        marble: The new state of `space` of type `abalone.enums.Marble`

    Raises:
        Exception: Cannot set state of `abalone.enums.Space.OFF`
    &#34;&#34;&#34;

    if space is Space.OFF:
        raise Exception(&#39;Cannot set state of `Space.OFF`&#39;)

    x, y = _space_to_board_indices(space)
    self.board[x][y] = marble</code></pre>
</details>
</dd>
<dt id="abalone.game.Game.switch_player"><code class="name flex">
<span>def <span class="ident">switch_player</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<section class="desc"><p>Switches the player whose turn it is.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Scriptim/Abalone-BoAi/blob/1623e8ef05411682f95dba45e6566e1275dbc901/abalone/game.py#L102-L104" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def switch_player(self) -&gt; None:
    &#34;&#34;&#34;Switches the player whose turn it is.&#34;&#34;&#34;
    self.turn = self.not_in_turn_player()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="abalone.game.IllegalMoveException"><code class="flex name class">
<span>class <span class="ident">IllegalMoveException</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Exception that is raised if a player tries to perform an illegal move.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Scriptim/Abalone-BoAi/blob/1623e8ef05411682f95dba45e6566e1275dbc901/abalone/game.py#L317-L318" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IllegalMoveException(Exception):
    &#34;&#34;&#34;Exception that is raised if a player tries to perform an illegal move.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="abalone" href="index.html">abalone</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="abalone.game.Game" href="#abalone.game.Game">Game</a></code></h4>
<ul class="">
<li><code><a title="abalone.game.Game.generate_legal_moves" href="#abalone.game.Game.generate_legal_moves">generate_legal_moves</a></code></li>
<li><code><a title="abalone.game.Game.generate_own_marble_lines" href="#abalone.game.Game.generate_own_marble_lines">generate_own_marble_lines</a></code></li>
<li><code><a title="abalone.game.Game.get_marble" href="#abalone.game.Game.get_marble">get_marble</a></code></li>
<li><code><a title="abalone.game.Game.get_score" href="#abalone.game.Game.get_score">get_score</a></code></li>
<li><code><a title="abalone.game.Game.move" href="#abalone.game.Game.move">move</a></code></li>
<li><code><a title="abalone.game.Game.move_broadside" href="#abalone.game.Game.move_broadside">move_broadside</a></code></li>
<li><code><a title="abalone.game.Game.move_inline" href="#abalone.game.Game.move_inline">move_inline</a></code></li>
<li><code><a title="abalone.game.Game.not_in_turn_player" href="#abalone.game.Game.not_in_turn_player">not_in_turn_player</a></code></li>
<li><code><a title="abalone.game.Game.set_marble" href="#abalone.game.Game.set_marble">set_marble</a></code></li>
<li><code><a title="abalone.game.Game.switch_player" href="#abalone.game.Game.switch_player">switch_player</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="abalone.game.IllegalMoveException" href="#abalone.game.IllegalMoveException">IllegalMoveException</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>